"""
Purpose: Take a LINGO .lng file parse it for the 
@POINTER assignments. Use the @POINTER assignments
to generate a Python LINGO API script
"""


import re
import sys
import os.path

def validateInput(fn:str) -> bool:
    # assume not valid
    bRet = True
    # need it to be modelName.lng 
    if(re.search(r"^[\w|\\|//]*(\w)+\.lng$", fn, re.IGNORECASE) == None):
        print(f"Invalivd file name {fn}. Must be path/to/model.lng")
        bRet = False

    if(bRet and os.path.exists(fn) == False):
        print(f"Invalivd file {fn}")
        bRet = False

    return bRet

def stripComments(RawContent):
    LngContent = ""
    # remove all comments
    bInComment = False
    for i in range(0,len(RawContent)):
        # save the curent char
        tmpChar = RawContent[i]
        # ! starts comments
        if(tmpChar == '!'):
            bInComment = True
        # blank out all comments
        if(bInComment == False):
            LngContent += RawContent[i]
        # ; ends comments if in one
        if(bInComment and tmpChar == ';'):
            bInComment = False

    return LngContent


def parseInput(fn:str):
    pointerNames = []
    pointerTypes = []
    # key attribute val set name
    AttributeDict = {}
    # key set name val dim string
    DerivedDict = {}
    # Open the file in read mode
    with open(fn, 'r') as lngfile:
        # Read the entire file content into a string
        RawContent = lngfile.read()

    # remove all comments to simplify
    lngContent = stripComments(RawContent)

    # make text lowwer case 
    lngContent = lngContent.lower()

    # get all the sets: - endsets sections into a list
    rawSetList = re.findall(r"sets:[a-z0-9\n\r\s:;\(\),/\._]*endsets", lngContent,  re.MULTILINE)
    
    # loop over each sets: - endsets section to extraxt data
    setNames = []
    for i in range(0,len(rawSetList)):

        tmp = rawSetList[i].strip('endset')
        tmp = tmp.strip('sets:')
        tmp = tmp.replace(' ', '')
        tmp = tmp.split("\n")
        
        for line in tmp:
            setName = ""
            if(line):
                if(":" in line):
                    setName,data =line.split(":")
                else:
                    setName = line.strip(";")
                    data = ""
                # prep the atter data
                data = data.strip(";")
                data = data.split(",")
                # add atter data to dict
                for atter in data:
                    AttributeDict[atter] = setName
               
                
            if("(" in setName):
                setName, derived = setName.split("(")
                derived = derived.strip(")")
                derived = derived.replace(",", " x ")
                DerivedDict[setName] = derived
               

            if(setName):
                setNames.append(setName)
            

            

    # make a list of each pointer assignment 
    # data = @Pointer(n)
    rawPointerList = re.findall(r"\w*\s*=\s*@POINTER", lngContent,  re.IGNORECASE)
    # @Pointer(n) = data
    rawPointerList += re.findall(r"\s*@POINTER\(\s*\w*\s*\)\s*=\s@?\w*\s*", lngContent,  re.IGNORECASE)

    # loop over pointer lis
    for i in range(0,len(rawPointerList)):

        tmp = rawPointerList[i]
        tmp = tmp.strip('\n')
        tmp = tmp.replace(" ","")
        lhs, rhs = tmp.split('=')
        # if pointer is RHS it is a lingo.VAR
        if("@pointer" in lhs):
            rhs = rhs.replace('@','')
            pointerNames.append(rhs)
            pointerTypes.append("lingo.VAR")

        elif("@pointer" in rhs):
            lhs = lhs.replace('@','')
            pointerNames.append(lhs)
            # if a set name then lingo.SET
            if(lhs in setNames):
                pointerTypes.append("lingo.SET")
            # other wise it is a lingo.PARAM
            else:
                pointerTypes.append("lingo.PARAM")
        else:
            pass

    

    return pointerNames, pointerTypes, AttributeDict, DerivedDict

def genScript(pointerNames, pointerTypes, AttributeDict, DerivedDict, fnLng):

    pyScript = """
# Generated by LINGO_to_Py.py
import lingo_api as lingo
import numpy as np
import pandas as pd
    
uData =  {'Prefix':'Lingo API', 'LastIter':-1,}
# Setting a default cbError function to catch any errors in
def cbError(pEnv, uData, nErrorCode, errorText):
    raise lingo.CallBackError(nErrorCode, errorText)

# Callback solver 
def cbSolver(pEnv, nReserved, uData):
    # Allocate the numpy arrays for API callback getter functions
    nIters   = np.array([-1],dtype=np.int32)

    # Get the current iteration
    errorcode = lingo.pyLSgetIntCallbackInfoLng(pEnv, lingo.LS_IINFO_ITERATIONS_LNG, nIters)
    
    if nIters[0] > 0 and uData["LastIter"] < nIters[0]:
        # update the LastIter saved in uData
        uData["LastIter"] = nIters[0]
        callbackStr = f"{uData['Prefix']:15} Iteration: {nIters[0]}"
        print(callbackStr)
    return 0
    """
    pyScript += "\n\n"
    pyScript += "# Path to LINGO file\n"
    pyScript += f"lngFile = '{fnLng}'\n"
    pyScript += "\n\n"
    pyScript += "# Define model data:\n"

    for i in range(0,len(pointerNames)):
        helperStr = ""
        if(pointerTypes[i] == "lingo.SET" and DerivedDict.get(pointerNames[i] ) != None):
            derivedFrom = DerivedDict.get(pointerNames[i])
            helperStr = f"{pointerNames[i]} is derived from {derivedFrom}"
        elif(pointerTypes[i] == "lingo.SET"):
            helperStr = f"Set data"
        elif(pointerTypes[i] == "lingo.PARAM" and AttributeDict.get(pointerNames[i]) != None):
            atterOfSet= AttributeDict.get(pointerNames[i])
            helperStr = f"{pointerNames[i]} is an attribute of set {atterOfSet}"
        else:
            helperStr = f"Var data"

        pyScript += (f"# {helperStr}\n")
        pyScript += (f"{pointerNames[i].upper()} = \n")


    pyScript += "\n\n"
    pyScript += "# Create a model object\n"
    pyScript += "model = lingo.Model(lngFile)"
    pyScript += "\n\n"
    pyScript += "# Add pointer data to model\n"
    for i in range(0,len(pointerNames)):
         pyScript += (f"model.set_pointer('Pointer{i+1}',{pointerNames[i].upper()},{pointerTypes[i]})\n")
    
    pyScript += "\n\n"
    pyScript += "# Set the call back function and user data\n"
    pyScript += "model.set_cbError(cbError)\n"
    pyScript += "model.set_cbSolver(cbSolver)\n"
    pyScript += "model.set_uData(uData)\n"
    pyScript += "# Now that everything is set call solve(model)\n"
    pyScript += "lingo.solve(model)\n"

    return pyScript



def main():
    
    
    if(len(sys.argv) <= 1):
        fnLNG = input("Enter LNG file: ")
    else:
        fnLNG = sys.argv[1]

    fnLNG = fnLNG.lower()

    # varify that we have a valid lng file
    if(validateInput(fnLNG) == False):
        return

    # open file to parse @POINTER calls
    pointerNames, pointerTypes, AttributeDict, DerivedDict = parseInput(fnLNG)
    
    pyScript = genScript(pointerNames, pointerTypes, AttributeDict, DerivedDict, fnLNG)

    fnPy = fnLNG.replace(".lng",".py")

    with open(fnPy, 'w+') as pyfile:
        # Read the entire file content into a string
        pyfile.write(pyScript)

    print(f"Generated {fnPy} from {fnLNG}")
    return




main()